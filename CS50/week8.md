# Stack
堆疊（英語：stack）又稱為棧或堆棧，是電腦科學中的一種抽象資料型別，
只允許在有序的線性資料集合的一端（稱為堆疊頂端，英語：top）進行加入資料（英語：push）和移除資料（英語：pop）的運算。
因而按照後進先出（LIFO, Last In First Out）的原理運作。

<img src='https://github.com/yen880405/yenlin/blob/master/image/%E4%B8%8B%E8%BC%89%20(2).png'>


# Queue
佇列，又稱為隊列（queue），是先進先出（FIFO, First-In-First-Out）的線性表。在具體應用中通常用鍊表或者數組來實現。佇列只允許在後端（稱為rear）進行插入操作，在前端（稱為front）進行刪除操作。

佇列的操作方式和堆疊類似，唯一的區別在於佇列只允許新數據在後端進行添加。


<img src='https://github.com/yen880405/yenlin/blob/master/image/%E4%B8%8B%E8%BC%89%20(3).png'>

# BST
二元搜尋樹（英語：Binary Search Tree），也稱為有序二元樹（ordered binary tree）或排序二元樹（sorted binary tree），是指一棵空樹或者具有下列性質的二元樹：

若任意節點的左子樹不空，則左子樹上所有節點的值均小於它的根節點的值；
若任意節點的右子樹不空，則右子樹上所有節點的值均大於它的根節點的值；
任意節點的左、右子樹也分別為二元搜尋樹；
沒有鍵值相等的節點。
二元搜尋樹相比於其他資料結構的優勢在於尋找、插入的時間複雜度較低。為O(log n)。二元搜尋樹是基礎性資料結構，用於構建更為抽象的資料結構，如集合、多重集、關聯陣列等。

二元搜尋樹的尋找過程和次優二元樹類似，通常採取二元連結串列作為二元搜尋樹的儲存結構。
中序遍歷二元搜尋樹可得到一個關鍵字的有序序列，一個無序序列可以透過建構一棵二元搜尋樹變成一個有序序列，
建構樹的過程即為對無序序列進行尋找的過程。每次插入的新的結點都是二元搜尋樹上新的葉子結點，在進行插入操作時，不必移動其它結點，
只需改動某個結點的指標，由空變為非空即可。
搜尋、插入、刪除的複雜度等於樹高，期望O(log n)，最壞O(n)（數列有序，樹退化成線性表）。

雖然二元搜尋樹的最壞效率是O(n)，但它支援動態查詢，且有很多改進版的二元搜尋樹可以使樹高為O(log n)，從而將最壞效率降至O(log n)，如AVL樹、紅黑樹等。

<img src='https://github.com/yen880405/yenlin/blob/master/image/%E4%B8%8B%E8%BC%89%20(4).png'>

stack跟queue最經典代表就是BFS和DFS，可引出有更價值的驗算法，分別為BFS和DFS的原因是一個是照順序爬，
一個是爬最後一個字，而有所不同;BST-二元樹有一個大規則就是左小右大，符合這些條件下，都可以稱之為BST，
還有一個進階版的red black tree，加上平衡之後又變得更難掌握了。





參考資料：https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88
https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97
https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9
