# 時間複雜度
在電腦科學中，演算法的時間複雜度（Time complexity）是一個函式，它定性描述該演算法的執行時間。這是一個代表演算法輸入值的字串的長度的函式。時間複雜度常用大O符號表述，不包括這個函式的低階項和首項係數。使用這種方式時，時間複雜度可被稱為是漸近的，亦即考察輸入值大小趨近無窮時的情況。例如，如果一個演算法對於任何大小為 n （必須比 n0 大）的輸入，它至多需要 5n3 + 3n 的時間執行完畢，那麼它的漸近時間複雜度是 O(n3)。

為了計算時間複雜度，我們通常會估計演算法的操作單元數量，每個單元執行的時間都是相同的。因此，總運行時間和演算法的操作單元數量最多相差一個常數係數。

相同大小的不同輸入值仍可能造成演算法的執行時間不同，因此我們通常使用演算法的最壞情況複雜度，記為 T(n) ，定義為任何大小的輸入 n 所需的最大執行時間。另一種較少使用的方法是平均情況複雜度，通常有特別指定才會使用。時間複雜度可以用函式 T(n) 的自然特性加以分類，舉例來說，有著 T(n) = O(n) 的演算法被稱作「線性時間演算法」；而 T(n) = O(Mn) 和 Mn= O(T(n)) ，其中 M ≥ n > 1 的演算法被稱作「指數時間演算法」。
<img src='https://github.com/yen880405/yenlin/blob/master/image/kk.png'>

# O與Ω符號
* O符號：表示最壞情況下的運行時間。
* Ω符號：表示最佳情況下的運行時間。

# Bubble sort

泡沫排序（英語：Bubble Sort）又稱為泡式排序，是一種簡單的排序演算法。它重複地走訪過要排序的數列，一次比較兩個元素，如果他們的順序錯誤就把他們交換過來。走訪數列的工作是重複地進行直到沒有再需要交換，也就是說該數列已經排序完成。這個演算法的名字由來是因為越小的元素會經由交換慢慢「浮」到數列的頂端。
泡沫排序對n個項目需要O(n^2)的比較次數，且可以原地排序。儘管這個演算法是最簡單瞭解和實作的排序演算法之一，但它對於包含大量的元素的數列排序是很沒有效率的。

* 最佳時間複雜度：O(n)

* 平均時間複雜度：O(n^2)

* 最差時間複雜度：O(n^2)

* 空間複雜度：O(1)

# Selection sort

選擇排序（Selection sort）是一種簡單直觀的排序演算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然後，再從剩餘未排序元素中繼續尋找最小（大）元素，然後放到已排序序列的末尾。以此類推，直到所有元素均排序完畢。

* 最佳時間複雜度：O(n^2)

* 平均時間複雜度：O(n^2)

* 最差時間複雜度：O(n^2)

* 空間複雜度：O(1)

# Insertion sort

插入排序（英語：Insertion Sort）是一種簡單直觀的排序演算法。它的工作原理是通過構建有序序列，對於未排序資料，在已排序序列中從後向前掃描，找到相應位置並插入。插入排序在實現上，通常採用in-place排序（即只需用到O(1)的額外空間的排序），因而在從後向前掃描過程中，需要反覆把已排序元素逐步向後挪位，為最新元素提供插入空間。

* 最佳時間複雜度：O(n)

* 平均時間複雜度：O(n^2)

* 最差時間複雜度：O(n^2)

* 空間複雜度：O(1)


# 小心得
全英文版的上課內容確實有些吃力，但還是很努力看完了，這week教bubble sort、insertion sort和selection sort，還好學校有先聽過，且授課內容大同小異，有點複習的意味存在。

參考資料：https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6
https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F
https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F
https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F
